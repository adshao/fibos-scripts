'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ByteBuffer = require('bytebuffer');
var Struct = require('./struct');

module.exports = {
  create: create,
  toBuffer: toBuffer,
  fromBuffer: fromBuffer

  /**
    @summary Create a serializer for each definition.
    @return {CreateStruct}
  */
};function create(definitions, types) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : types.config;

  var errors = [];
  if (!config.sort) {
    config.sort = {};
  }

  // Basic structure validation
  for (var key in definitions) {
    var value = definitions[key];
    var base = value.base,
        fields = value.fields;

    var typeOfValue = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    if (typeOfValue === 'object') {
      if (!base && !fields) {
        errors.push('Expecting ' + key + '.fields or ' + key + '.base');
        continue;
      }
      if (base && typeof base !== 'string') {
        errors.push('Expecting string ' + key + '.base');
      }
      if (fields) {
        if ((typeof fields === 'undefined' ? 'undefined' : _typeof(fields)) !== 'object') {
          errors.push('Expecting object ' + key + '.fields');
        } else {
          for (var field in fields) {
            if (typeof fields[field] !== 'string') {
              errors.push('Expecting string in ' + key + '.fields.' + field);
            }
          }
        }
      }
    } else if (typeOfValue !== 'string') {
      errors.push('Expecting object or string under ' + key + ', instead got ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));
      continue;
    }
  }

  // Keys with objects are structs
  var structs = {};
  for (var _key in definitions) {
    var _value = definitions[_key];
    if ((typeof _value === 'undefined' ? 'undefined' : _typeof(_value)) === 'object') {
      structs[_key] = Struct(_key, config);
    }
  }

  // Resolve user-friendly typedef names pointing to a native type (or another typedef)
  for (var _key2 in definitions) {
    var _value2 = definitions[_key2];
    if (typeof _value2 === 'string') {
      var type = types[_value2];
      if (type) {
        types[_key2] = type;
      } else {
        // example: key === 'fields' && value === field[]
        var struct = getTypeOrStruct(_key2, _value2); // type = vector(field)
        if (struct) {
          structs[_key2] = struct;
        } else {
          errors.push('Unrecognized type or struct ' + _key2 + '.' + _value2);
        }
      }
    }
  }

  // Structs can inherit another struct, they will share the same instance
  for (var _key3 in definitions) {
    var thisStruct = structs[_key3];
    if (!thisStruct) continue;
    var _value3 = definitions[_key3];
    if ((typeof _value3 === 'undefined' ? 'undefined' : _typeof(_value3)) === 'object' && _value3.base) {
      var base = _value3.base;
      var baseStruct = structs[base];
      if (!baseStruct) {
        errors.push('Missing ' + base + ' in ' + _key3 + '.base');
        continue;
      }
      thisStruct.add('', structPtr(baseStruct));
    }
  }

  // Create types from a string (ex vector[Type])
  function getTypeOrStruct(key, Type, typeArgs, fieldName) {
    var typeatty = parseType(Type);
    if (!typeatty) return null;
    var name = typeatty.name,
        annotation = typeatty.annotation,
        arrayType = typeatty.arrayType;

    var ret = void 0;
    if (annotation) {
      // any_type<field_name, type_name>
      var _type = types[name];
      if (_type == null) {
        errors.push('Missing ' + name + ' in ' + Type);
        return null;
      }
      var annTypes = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = annotation[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var annTypeName = _step.value;

          var annType = getTypeOrStruct(key, annTypeName, null, fieldName);
          if (!annType) {
            errors.push('Missing ' + annTypeName + ' in ' + Type);
            return null;
          }
          annTypes.push(annType);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      ret = _type(annTypes);
    } else if (arrayType == null) {
      // AnyType
      var fieldStruct = structs[name];
      if (fieldStruct) {
        return fieldStruct;
      }

      var _type2 = types[name];
      if (!_type2) {
        return null;
      }

      // types need to be instantiated
      ret = _type2(typeArgs);
    } else if (arrayType === '') {
      // AnyType[]
      var nameType = getTypeOrStruct(key, typeatty.name, null, fieldName);
      if (!nameType) {
        return null;
      }

      var sort = config.sort[key + '.' + fieldName] || false;
      // console.log('sort?', `${key}.${fieldName}`, sort, config.sort)
      ret = types.vector(nameType, sort);
    } else if (arrayType.length > 0) {
      // vector[Type]
      var arrayTs = getTypeOrStruct(key, typeatty.arrayType, null, fieldName);
      if (!arrayTs) {
        errors.push('Missing ' + typeatty.arrayType + ' in ' + Type);
        return null;
      }
      var baseTs = getTypeOrStruct(key, typeatty.name, arrayTs, fieldName);
      if (!baseTs) {
        errors.push('Missing ' + typeatty.name + ' in ' + Type);
        return null;
      }
      ret = baseTs;
    }
    return typeatty.optional ? types.optional(ret) : ret;
  }

  // Add all the fields.  Thanks to structPtr no need to look at base types.
  for (var _key4 in definitions) {
    var _thisStruct = structs[_key4];
    if (!_thisStruct) continue;
    var _value4 = definitions[_key4];
    if (!_value4.fields) continue;
    var fields = _value4.fields;

    for (var Field in fields) {
      var Type = fields[Field];
      var ts = getTypeOrStruct(_key4, Type, null, Field);
      if (!ts) {
        errors.push('Missing ' + Type + ' in ' + _key4 + '.fields.' + Field);
        continue;
      }
      _thisStruct.add(Field, ts);
    }
  }

  if (errors.length) {
    // 'structs' could contain invalid references
    return { errors: errors };
  }

  return { errors: errors, structs: structs };
}

var parseType = function parseType(name) {
  if (!name || typeof name !== 'string') {
    return null;
  }

  name = name.trim();

  var annotationMatch = name.match(/<(.*)>/);
  if (annotationMatch) {
    var annotation = annotationMatch ? annotationMatch[1].replace(/ /g, '').split(',') : null;

    name = name.replace(annotationMatch[0], '').trim();
    return { name: name, annotation: annotation };
  }

  var arrayMatch = name.match(/\[(.*)\]/);
  var arrayType = arrayMatch ? arrayMatch[1].trim() : null;

  if (arrayMatch) {
    name = name.replace(arrayMatch[0], '').trim();
  }

  var optional = false;
  if (/\?$/.test(name)) {
    name = name.substring(0, name.length - 1);
    optional = true;
  }
  return { name: name, arrayType: arrayType, optional: optional };
};

/**
  Base types all point to the same struct.

  Note, appendByteBuffer has no return type.
*/
var structPtr = function structPtr(type) {
  return {
    fromByteBuffer: function fromByteBuffer(b) {
      return type.fromByteBuffer(b);
    },
    appendByteBuffer: function appendByteBuffer(b, value) {
      type.appendByteBuffer(b, value);
    },
    fromObject: function fromObject(value) {
      return type.fromObject(value);
    },
    toObject: function toObject(value) {
      return type.toObject(value);
    }
  };
};

function toBuffer(type, value) {
  var struct = type.fromObject(value);
  return Buffer.from(toByteBuffer(type, struct).toBinary(), 'binary');
}

function fromBuffer(type, buffer) {
  var toObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  var b = ByteBuffer.fromBinary(buffer.toString('binary'), ByteBuffer.LITTLE_ENDIAN);
  var struct = type.fromByteBuffer(b);
  return toObject ? type.toObject(struct) : struct;
}

function toByteBuffer(type, value) {
  var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
  type.appendByteBuffer(b, value);
  return b.copy(0, b.offset);
}